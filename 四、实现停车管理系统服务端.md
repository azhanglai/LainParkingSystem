[TOC]

### 1、服务器所有的文件数据包整理

#### 1.1 package.h 头文件

~~~c++
#ifndef __DEFINE_FILE_H
#define __DEFINE_FILE_H

#define MAX_SIZE        1024    // 最大长度

// 数据包类型的宏定义
#define ERROR_NUMBER    -1      // 错误信息
#define REGIST_TYPE     1       // 用户注册包 
#define LOGIN_TYPE      2       // 用户登录包
#define PHOTO_TYPE      3       // 图片包
#define CAR_GETIN       4       // 汽车入场包
#define CAR_GETOUT      5       // 汽车出场包
#define HEART_TYPE      6       // 连接心跳包
#define CAR_MSG_TYPE    7       // 汽车信息包
#define VIDEO_TYPE      8       // 视频记录包
#define VIDEO_OPEN      9       // 视频打开
#define VIDEO_CLOSE     10      // 视频关闭
#define OFFLINE_TYPE    11      // 用户下线包

/* 消息队列结构体 */
typedef struct {
    long mtype;
    char mtext[12];
} MYBUF;

/* 心跳包结构体 */
typedef struct {
    int fd;				
    int time;
} PACK_HEART;

/* 数据包头 */
typedef struct {
    int bodyType;		// 数据包类型
    int bodySize;		// 数据包大小
    int crcCode;		// 校验码
    char seqNum[36];	// 流水号
} PACK_HEAD;

/* 登录注册包体 */
typedef struct {
    char name[24];		// 用户账号
    char pwd[16];		// 用户密码
} PACK_REGIST_LOGIN;

/* 登录注册反馈包体 */
typedef struct {
    int result;			// 0：成功，1：用户名错误，2：密码错误
} PACK_RL_BACK;

/* 汽车入场包 */
typedef struct {
    int number;				// 序号
    char car_num[18];		// 车牌号
    char now_time[36];		// 当前时间
    char location[12];		// 位置
    char photo_path[100];	// 图片路径
} PACK_ENTER;

/* 图片包 */
typedef struct {
    char filename[40];		// 文件名
    int realSize;			// 实际大小
    int num;				// 包的序号
    int sum;				// 包的总数
    char context[MAX_SIZE];	// 存储数据的数组
} PACK_PHOTO;

/* 图片反馈 */
typedef struct {
    int result;				// 1：收到了，继续发 0：没收到
} PACK_PHOTO_BACK;

/* 汽车出场包 */
typedef struct {
    char car_num[18];		// 车牌号
    char out_time[36];		// 出场时间
} PACK_EXIT;

/* 汽车出场反馈 */
typedef struct {
    char in_time[36];		// 入场时间
    int vip;				// 是否VIP
    char total_time[64];	// 停车时长
    int money;				// 停车金额
} PACK_EXIT_BACK;

/* 汽车信息包 */
typedef struct mycarmsg {
    char car_num[18];		// 车牌号
    char in_time[36];		// 入场时间
    char out_time[36];		// 出场时间
    int page;				// 第几页
} PACK_CARMSG;

/* 汽车信息反馈 */
typedef struct {
    char car_num[18];		// 车牌号
    char in_time[36];		// 入场时间
    char out_time[36];		// 出场时间
    int money;				// 停车金额
} PACK_CARMSG_BACK;

/* 全部汽车信息反馈 */
typedef struct {
    int realCount;			// 实际的数据条数
    int totalCount;			// 总条数
    PACK_CARMSG_BACK arr[4];// 汽车信息反馈数组
} PACK_ALLCARMSG_BACK;

/* 视频包 */
typedef struct {
    char video_name[24];	// 视频名称 
    int frameCount;			// 记录帧数
    int totalFrameCount;	// 总帧数
} PACK_VIDEO;

/* 视频反馈 */
typedef struct {
    int frameCount;			// 记录帧数
} PACK_VIDEO_BACK;

#endif /* __DEFINE_FILE_H */

~~~

#### 1.2 define.h 头文件

~~~c++
#ifndef _DEFINE_H
#define _DEFINE_H

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <fcntl.h>
#include <assert.h>
#include <errno.h>
#include <time.h>
#include <signal.h>
#include <sys/epoll.h>
#include <sys/socket.h>
#include <sys/stat.h>   
#include <sys/mman.h>
#include <sys/types.h>
#include <sys/uio.h>
#include <sys/ipc.h>
#include <sys/msg.h>
#include <sys/shm.h>
#include <sys/wait.h>
#include <netinet/in.h>
#include <netinet/ip.h>
#include <arpa/inet.h>
#include <malloc.h>

#endif /*  _DEFINE_H */
~~~

### 2、基于EpollServer服务器框架完善线程处理函数框架

~~~c++
#ifndef _EPOLLSERVER_H
#define _EPOLLSERVER_H

#include "./define.h"
#include "./epoller.h"
#include "./threadpool.h" 
#include <memory>

class EpollServer {
public:
    EpollServer(int port, bool OptLinger, int trigMode, int threadNum); 
    ~EpollServer();
    void Start();							

private:
    int m_port;								
    bool m_openLinger;						
    bool m_isClose;							
    int m_listenFd;							
    
    uint32_t m_listenEvent; 				
    uint32_t m_connEvent;					
    
    std::unique_ptr<Epoller> m_epoller;		

    bool _Init_Socket();					
    void _Init_EventMode(int trigMode);		
    static int Set_FdNonblock(int fd);		
    
    void _Deal_Listen();
    void _Deal_Read(int fd);				
    void _Deal_Write(int fd);				
    
	void _Thread_Read(int fd); 				// 需要待完善的线程任务函数
    void _Thread_Write(int fd); 			// 需要待完善的线程任务函数
};

#endif /* _EPOLLSERVER_H */
~~~

#### 2.1 完善_Thread_Read()函数

~~~c++
void EpollServer::_Thread_Read(int fd) {
    // 有客户端发送数据过来
    MYBUF msg;
    msg.mtype = 1;
    PACK_HEAD head;
    bzero(&head, sizeof(PACK_HEAD));
	// 读取客户端发来的头部数据包
    int ret = read(fd, &head, sizeof(head));
    if (ret > 0) {
        // 根据头部数据包的类型来处理
        // 注册
        if (head.bodyType == REGIST_TYPE) {

        }
        // 登录
        else if (head.bodyType == LOGIN_TYPE) {

        }
        // 汽车入停车场
        else if (head.bodyType == CAR_GETIN) {

        }
        // 汽车出停车场
        else if (head.bodyType == CAR_GETOUT) {
            
        }
        // 心跳
        else if (head.bodyType == HEART_TYPE) {
            
        }
        // 图片
        else if (head.bodyType == PHOTO_TYPE) {
           
        }
        // 车辆信息
		else if (head.bodyType == CAR_MSG_TYPE) {
		
		}
        // 视频信息
		else if (head.bodyType == VIDEO_TYPE) {
			
		}
        // 打开视频
		else if (head.bodyType == VIDEO_OPEN) {

		}
        // 关闭视频
		else if (head.bodyType == VIDEO_CLOSE) {

		}
	}
	else {
		// 客户端断开连接
		return ;
    }
}
~~~

#### 2.2 完善_Thread_write()函数

~~~c++
void EpollServer::_Thread_Write(int fd) {
    while (true) {
        // 使用消息队列+共享内存来实现两个进程间的通信
        // 1个进程负责与客户端对接，另1个进程负责处理客户端发过来的数据
        MYBUF* msg = (MYBUF*)malloc(sizeof(MYBUF));
        size_t msgsize = sizeof(MYBUF) - sizeof(long);
        int ret = msgrcv(msgid_back, msg, msgsize, 2, 0);       
        char buffer[1024] = {0};
        memcpy(buffer, shm_fifo.shm_read(), sizeof(buffer));

        PACK_HEAD* head = (PACK_HEAD*)malloc(sizeof(PACK_HEAD));
        memcpy(head, buffer, sizeof(PACK_HEAD));

        // 注册
        if (head->bodyType == REGIST_TYPE) {
            
		}
        // 登录
		else if (head->bodyType == LOGIN_TYPE) {
			
		}
        // 汽车入场
		else if (head->bodyType == CAR_GETIN) {
			
		}
        // 汽车出场
		else if (head->bodyType == CAR_GETOUT) {
			
		}
        // 汽车信息
		else if (head->bodyType == CAR_MSG_TYPE) {
			
		}
        // 打开视频
		else if (head->bodyType == VIDEO_OPEN) {

		}
		free(msg); msg = NULL;
		free(head); head = NULL;
    }
}
~~~

### 3、停车管理系统EpollServer

#### 3.1 epollserver.h 头文件

~~~c++
#ifndef _EPOLLSERVER_H
#define _EPOLLSERVER_H

#include "./define.h"
#include "./pakeage.h"
#include "./shmfifo.h"
#include "./epoller.h"
#include "./threadpool.h" 
#include <memory>
#include <map>
using namespace std;

class EpollServer {
public:
    EpollServer(int port, bool OptLinger, int trigMode, int threadNum); 
    ~EpollServer();
    void Start();							

private:
    int m_port;								
    bool m_openLinger;						
    bool m_isClose;							
    int m_listenFd;
    
    int m_msgid;
    int m_msgid_back;
    
    uint32_t m_listenEvent; 				
    uint32_t m_connEvent;					
    
    static map<int, PACK_HEART> conntimer;
    static mutex mtx;
    
    unique_ptr<Epoller> m_epoller;		
    unique_ptr<ThreadPool> m_threadpool;		

    bool _Init_Socket();					
    void _Init_EventMode(int trigMode);		
    static int Set_FdNonblock(int fd);		
    
    void _Deal_Listen();
    void _Deal_Read(int fd);				
    void _Deal_Write(int fd);				
    
	void _Thread_Read(int fd); 		
    void _Thread_Write(int fd); 			
    void _Thread_Heart();
    
    void _Close_Conn(int fd);
};

#endif /* _EPOLLSERVER_H */


~~~

#### 3.2 epollserver.cpp 源文件

~~~c++
#include "./epollserver.h"

ShmFifo shm_fifo1(11, 10, 1024);
ShmFifo shm_fifo2(22, 10, 1024);

map<int, PACK_HEART> EpollServer::conntimer;
mutex EpollServer::mtx;

EpollServer::EpollServer(int port, bool OptLinger, int trigMode, int threadNum)
    : m_port(port), m_openLinger(OptLinger),  m_isClose(false),
    m_epoller(new Epoller()), m_threadpool(new ThreadPool(threadNum))
{  
	m_msgid = msgget(1234, IPC_CREAT | IPC_EXCL | 0666);
    if (m_msgid == -1) {
        m_msgid = msgget(1234, 0);
    }

	m_msgid_back = msgget(12345, IPC_CREAT | IPC_EXCL | 0666);
	if (m_msgid_back == -1) {
        m_msgid_back = msgget(12345, 0);
	}

    _Init_EventMode(trigMode);
    if (!_Init_Socket()) {
        m_isClose = true;
    }
}

EpollServer::~EpollServer() {
    close(m_listenFd);
    m_isClose = true;
}

void EpollServer::Start() {
    if (!m_isClose) {
        printf("========== EpollServer Start ==========\n");
    }
    // 将客户连接心跳函数添加到线程
    m_threadpool->AddTask(std::bind(&EpollServer::_Thread_Heart, this));
    while (!m_isClose) {
        // m_epoller->Wait: 阻塞等待就绪事件，返回就绪事件的个数
        int nfd = m_epoller->Wait();
        for (int i = 0; i < nfd; ++i) {
            int fd = m_epoller->GetEventFd(i);			// 取得就绪事件的fd
            uint32_t events = m_epoller->GetEvents(i); 	// 取得就绪事件
            // 如果是监听套接字的事件就绪，说明有客户要连接
            if (fd == m_listenFd) {
                _Deal_Listen();
            }
            // 事件挂起或出错
            else if (events & (EPOLLRDHUP | EPOLLHUP | EPOLLERR)) {
                assert(fd > 0);
                _Close_Conn(fd);
            }
            // 客户读事件就绪
            else if (events & EPOLLIN) {
                assert(fd > 0);
                _Deal_Read(fd);
            }
            // 客户写事件就绪
            else if (events & EPOLLOUT) {
                assert(fd > 0);
                _Deal_Write(fd);
            }
            else {
                printf("Unexpected event\n");
            }
        }
    }   
} 

bool EpollServer::_Init_Socket() {
    int ret;
    struct sockaddr_in addr;
    if (m_port > 65535 || m_port < 1024) {
        printf("Port:%d error!\n", m_port);
        return false;
    }
    addr.sin_family = AF_INET;
    addr.sin_port = htons(m_port);
    addr.sin_addr.s_addr = htonl(INADDR_ANY);

    struct linger optLinger = {0};
    if (m_openLinger) {
        // 优雅关闭: 直到所剩数据发送完毕或超时
        optLinger.l_onoff = 1;
        optLinger.l_linger = 1;
    }

    m_listenFd = socket(AF_INET, SOCK_STREAM, 0);
    if (m_listenFd < 0) {
        printf("socket error!\n");
        return false;
    }

    ret = setsockopt(m_listenFd, SOL_SOCKET, SO_LINGER, &optLinger, sizeof(optLinger));
    if (ret < 0) {
        close(m_listenFd);
        printf("setsockopt1 error!\n");
        return false;
    }
    // 设置端口复用
    int val = 1;
    ret = setsockopt(m_listenFd, SOL_SOCKET, SO_REUSEADDR, (const void*)&val, sizeof(int));
    if (ret < 0) {
        close(m_listenFd);
        printf("setsockopt2 error!\n");
        return false;
    }
    // 绑定端口
    ret = bind(m_listenFd, (struct sockaddr*)&addr, sizeof(addr));
    if (ret < 0) {
        printf("bind error!\n");
        close(m_listenFd);
        return false;
    }
    // 监听套接字 
    ret = listen(m_listenFd, SOMAXCONN);
    if (ret < 0) {
        printf("listen error!\n");
        close(m_listenFd);
        return false; 
    }
    // 把监听fd注册到epoll
    ret = m_epoller->AddFd(m_listenFd, m_listenEvent | EPOLLIN);
    if (ret == 0) {
        close(m_listenFd);
        return false;
    }
    // 把监听fd 设置成非阻塞 
    Set_FdNonblock(m_listenFd);
    return true;
}

void EpollServer::_Init_EventMode(int trigMode) {
    // EPOLLONESHOT: 只监听一次事件，如还需要监听的话，需要再次把fd注册到epoll
    m_listenEvent = EPOLLRDHUP;
    m_connEvent = EPOLLRDHUP | EPOLLONESHOT;
    // 0：默认水平触发LT
    // 1：listen 为 LT， conn 为ET(边沿触发)
    // 2：listen 为 ET， conn 为LT
    // 3：listen 为 ET， conn 为ET
    switch (trigMode) {
        case 0: { break; }
        case 1: {
            m_connEvent |= EPOLLET;
            break;
        }
        case 2: {
            m_listenEvent |= EPOLLET;
            break;
        }
        case 3: {
            m_listenEvent |= EPOLLET;
            m_connEvent |= EPOLLET;
            break;
        }
        defalut: {
            m_listenEvent |= EPOLLET; 
            m_connEvent |= EPOLLET;
            break;
        }
    }
}

int EpollServer::Set_FdNonblock(int fd) {
    assert(fd > 0);
    return fcntl(fd, F_SETFL, fcntl(fd, F_GETFL, 0) | O_NONBLOCK);
}

void EpollServer::_Deal_Listen() {
    struct sockaddr_in cli_addr;
    socklen_t len = sizeof(cli_addr);
    do {
        int fd = accept(m_listenFd, (struct sockaddr*)&cli_addr,&len);
        if (fd <= 0) { return ; }
        // 给客户加上一个心跳包
        PACK_HEART heart;
        heart.fd = fd;
        heart.time = 128;
        conntimer.insert(pair<int, PACK_HEART>(fd, heart));
        m_epoller->AddFd(fd, m_connEvent | EPOLLIN);
        Set_FdNonblock(fd);
    } while (m_listenEvent & EPOLLET);
}

void EpollServer::_Deal_Read(int fd) {
    m_threadpool->AddTask(std::bind(&EpollServer::_Thread_Read, this, fd));
}

void EpollServer::_Deal_Write(int fd) {
    m_threadpool->AddTask(std::bind(&EpollServer::_Thread_Write, this, fd));
}
// 处理客户连接心跳
void EpollServer::_Thread_Heart() {
    while (true) {
        sleep(1);
        // 遍历每个客户，每次遍历时间-1，客户长时间不活跃，直到没有心跳时，关闭连接
        for (auto it = EpollServer::conntimer.begin(); it != EpollServer::conntimer.end(); ++it) {
            (*it).second.time--;
            if ((*it).second.time == 0) {
                {
                    lock_guard<mutex> locker(EpollServer::mtx);
                    _Close_Conn((*it).second.fd);
                    EpollServer::conntimer.erase(it);
                }

            }
        }
    }
}

void EpollServer::_Thread_Read(int fd) {  
    time_t nowTime;
    nowTime = time(NULL);

    // 获取当前系统时间
    struct tm* sysTime = localtime(&nowTime);
    char nowtime_buf[50] = {0};
    char nowtime_buffer[50] = {0};
    sprintf(nowtime_buf, "./log/%d-%02d-%02d.txt", sysTime->tm_year + 1900, sysTime->tm_mon + 1, sysTime->tm_mday);

    sprintf(nowtime_buffer, "%d-%02d-%02d/%02d:%02d:%02d", sysTime->tm_year + 1900, sysTime->tm_mon + 1, sysTime->tm_mday, sysTime->tm_hour, sysTime->tm_min, sysTime->tm_sec);

    // 有客户端发送数据过来
    MYBUF msg;
    msg.mtype = 1;
    size_t msgsize = sizeof(MYBUF) - sizeof(long);
    PACK_HEAD head;
    bzero(&head, sizeof(PACK_HEAD));

    int ret = read(fd, &head, sizeof(head));
    if (ret > 0) {
        // 注册
        if (head.bodyType == REGIST_TYPE) {
            PACK_REGIST_LOGIN regist_login;
            int res = read(fd, &regist_login, sizeof(PACK_REGIST_LOGIN));

            char buffer[sizeof(PACK_HEAD) + sizeof(PACK_REGIST_LOGIN)] = {0};
            memcpy(buffer, &head, sizeof(PACK_HEAD));
            memcpy(buffer + sizeof(PACK_HEAD), &regist_login, sizeof(PACK_REGIST_LOGIN));

            if (res > 0) {
                shm_fifo1.shm_write(buffer);
                int res = msgsnd(m_msgid, &msg, msgsize, 0);
            }
        }
        // 登录
        else if (head.bodyType == LOGIN_TYPE) {
            PACK_REGIST_LOGIN regist_login;
            int res = read(fd, &regist_login, sizeof(PACK_REGIST_LOGIN));

            char buffer[sizeof(PACK_HEAD) + sizeof(PACK_REGIST_LOGIN)] = {0};
            memcpy(buffer, &head, sizeof(PACK_HEAD));
            memcpy(buffer + sizeof(PACK_HEAD), &regist_login, sizeof(PACK_REGIST_LOGIN));

            if (res > 0) {
                shm_fifo1.shm_write(buffer);
                int res = msgsnd(m_msgid, &msg, msgsize, 0);
            }
        }
        // 汽车入停车场
        else if (head.bodyType == CAR_GETIN) {
            PACK_ENTER car_enter;
            int res = read(fd, &car_enter, sizeof(PACK_ENTER));

            char buffer[sizeof(PACK_HEAD) + sizeof(PACK_ENTER)] = {0};
            memcpy(buffer, &head, sizeof(PACK_HEAD));
            memcpy(buffer + sizeof(PACK_HEAD), &car_enter, sizeof(PACK_ENTER));

            if (res > 0) {
                shm_fifo1.shm_write(buffer);
                int res = msgsnd(m_msgid, &msg, msgsize, 0);
            }
        }
        // 汽车出停车场
        else if (head.bodyType == CAR_GETOUT) {
            PACK_EXIT car_exit;
            int res = read(fd, &car_exit, sizeof(PACK_EXIT));
            
            char buffer[sizeof(PACK_HEAD) + sizeof(PACK_EXIT)] = {0};
            memcpy(buffer, &head, sizeof(PACK_HEAD));
            memcpy(buffer + sizeof(PACK_HEAD), &car_exit, sizeof(PACK_EXIT));

            if (res > 0) {
                shm_fifo1.shm_write(buffer);
                int res = msgsnd(m_msgid, &msg, msgsize, 0);
            }
        }
        // 心跳
        else if (head.bodyType == HEART_TYPE) {
            auto it = EpollServer::conntimer.find(fd);
            if (it != EpollServer::conntimer.end()) {
                {
                    lock_guard<mutex> locker(EpollServer::mtx);
                    (*it).second.time = 128;
                }
            }
        }
        // 图片
        else if (head.bodyType == PHOTO_TYPE) {
            PACK_PHOTO photo_pack;
            PACK_PHOTO_BACK photo_result;
            int res = read(fd, &photo_pack, sizeof(PACK_PHOTO));
            char fileName[24] = {0};
            sprintf(fileName, "./photo/%s", photo_pack.filename);

            FILE* fp;
            fp = fopen(fileName, "a+");
            fwrite(photo_pack.context, photo_pack.realSize, 1, fp);
            fclose(fp);

            photo_result.result = 1;

            char sendbuffer[sizeof(PACK_HEAD) + sizeof(PACK_PHOTO_BACK)] = {0};
            memcpy(sendbuffer, &head, sizeof(PACK_HEAD));
            memcpy(sendbuffer + sizeof(PACK_HEAD), &photo_result, sizeof(PACK_PHOTO_BACK));
            int n = write(fd, sendbuffer, sizeof(sendbuffer));
        }
        // 车辆信息
		else if (head.bodyType == CAR_MSG_TYPE) {
			PACK_CARMSG car_msg;
			int res = read(fd, &car_msg, sizeof(PACK_CARMSG));

			char buffer[sizeof(PACK_HEAD) + sizeof(PACK_CARMSG)] = { 0 };
			memcpy(buffer, &head, sizeof(PACK_HEAD));
			memcpy(buffer + sizeof(PACK_HEAD), &car_msg, sizeof(PACK_CARMSG));

			if (res > 0) {
				shm_fifo1.shm_write(buffer);
				int res = msgsnd(m_msgid, &msg, msgsize, 0);
            }
		}
        // 视频信息
		else if (head.bodyType == VIDEO_TYPE) {
			PACK_VIDEO video;
			int res = read(fd, &video, sizeof(PACK_VIDEO));
			char buffer[sizeof(PACK_HEAD) + sizeof(PACK_VIDEO)] = { 0 };
			memcpy(buffer, &head, sizeof(PACK_HEAD));
			memcpy(buffer + sizeof(PACK_HEAD), &video, sizeof(PACK_VIDEO));

			if (res > 0) {
				shm_fifo1.shm_write(buffer);
				int res = msgsnd(m_msgid, &msg, msgsize, 0);
            }
		}
        // 打开视频
		else if (head.bodyType == VIDEO_OPEN) {
			PACK_VIDEO video;
			int res = read(fd, &video, sizeof(PACK_VIDEO));
			
			char buffer[sizeof(PACK_HEAD) + sizeof(PACK_VIDEO)] = { 0 };
			memcpy(buffer, &head, sizeof(PACK_HEAD));
			memcpy(buffer + sizeof(PACK_HEAD), &video, sizeof(PACK_VIDEO));

			if (res > 0) {
				shm_fifo1.shm_write(buffer);
				int res = msgsnd(m_msgid, &msg, msgsize, 0);
            }
		}
        // 关闭视频
		else if (head.bodyType == VIDEO_CLOSE) {
			PACK_VIDEO video_close;
			int res = read(fd, &video_close, sizeof(PACK_VIDEO));
			char buffer[sizeof(PACK_HEAD) + sizeof(PACK_VIDEO)] = { 0 };
			memcpy(buffer, &head, sizeof(PACK_HEAD));
			memcpy(buffer + sizeof(PACK_HEAD), &video_close, sizeof(PACK_VIDEO));

			if (res > 0) {
				shm_fifo1.shm_write(buffer);
				int res = msgsnd(m_msgid, &msg, msgsize, 0);
            }
		}
	}
	else {
		// 客户端断开连接
		printf("client error close\n");
		_Close_Conn(fd);
		return;
    }

    m_epoller->ModFd(fd, m_connEvent | EPOLLOUT);
}

void EpollServer::_Thread_Write(int fd) { 
	while (true) {
        size_t msgsize = sizeof(MYBUF) - sizeof(long); 
        MYBUF* msg = (MYBUF*)malloc(sizeof(MYBUF));
        int ret = msgrcv(m_msgid_back, msg, msgsize, 2, 0);
        if (ret == -1) {
            perror("msgrcv");
        }
        
        char rec_buffer[1024] = {0};
        memcpy(rec_buffer, shm_fifo2.shm_read(), sizeof(rec_buffer));

        PACK_HEAD* head = (PACK_HEAD*)malloc(sizeof(PACK_HEAD));
        memcpy(head, rec_buffer, sizeof(PACK_HEAD));
        // 注册
        if (head->bodyType == REGIST_TYPE) {
            char body_buffer[sizeof(PACK_RL_BACK)] = { 0 };
			memcpy(body_buffer, rec_buffer + sizeof(PACK_HEAD), sizeof(PACK_RL_BACK));

			char total_buffer[sizeof(PACK_HEAD) + sizeof(PACK_RL_BACK)] = { 0 };
			memcpy(total_buffer, head, sizeof(PACK_HEAD));
			memcpy(total_buffer + sizeof(PACK_HEAD), body_buffer, sizeof(body_buffer));
			int res = write(fd, total_buffer, sizeof(total_buffer));
		}
        // 登录
		else if (head->bodyType == LOGIN_TYPE) {
			char body_buffer[sizeof(PACK_RL_BACK)] = { 0 };
			memcpy(body_buffer, rec_buffer + sizeof(PACK_HEAD), sizeof(PACK_RL_BACK));

			char total_buffer[sizeof(PACK_HEAD) + sizeof(PACK_RL_BACK)] = { 0 };
			memcpy(total_buffer, head, sizeof(PACK_HEAD));
			memcpy(total_buffer + sizeof(PACK_HEAD), body_buffer, sizeof(body_buffer));
			int res = write(fd, total_buffer, sizeof(total_buffer));
		}
        // 汽车入场
		else if (head->bodyType == CAR_GETIN) {
			char body_buffer[sizeof(PACK_RL_BACK)] = { 0 };
			memcpy(body_buffer, rec_buffer + sizeof(PACK_HEAD), sizeof(PACK_RL_BACK));

			char total_buffer[sizeof(PACK_HEAD) + sizeof(PACK_RL_BACK)] = { 0 };
			memcpy(total_buffer, head, sizeof(PACK_HEAD));
			memcpy(total_buffer + sizeof(PACK_HEAD), body_buffer, sizeof(body_buffer));
			int res = write(fd, total_buffer, sizeof(total_buffer));
		}
        // 汽车出场
		else if (head->bodyType == CAR_GETOUT) {
			char body_buffer[sizeof(PACK_EXIT_BACK)] = { 0 };
			memcpy(body_buffer, rec_buffer + sizeof(PACK_HEAD), sizeof(PACK_EXIT_BACK));

			char total_buffer[sizeof(PACK_HEAD) + sizeof(PACK_EXIT_BACK)] = { 0 };
			memcpy(total_buffer, head, sizeof(PACK_HEAD));
			memcpy(total_buffer + sizeof(PACK_HEAD), body_buffer, sizeof(body_buffer));
			int res = write(fd, total_buffer, sizeof(total_buffer));
		}
        // 汽车信息
		else if (head->bodyType == CAR_MSG_TYPE) {
			char body_buffer[sizeof(PACK_ALLCARMSG_BACK)] = { 0 };
			memcpy(body_buffer, rec_buffer + sizeof(PACK_HEAD), sizeof(PACK_ALLCARMSG_BACK));

			char total_buffer[sizeof(PACK_HEAD) + sizeof(PACK_ALLCARMSG_BACK)] = { 0 };
			memcpy(total_buffer, head, sizeof(PACK_HEAD));
			memcpy(total_buffer + sizeof(PACK_HEAD), body_buffer, sizeof(body_buffer));
			int res = write(fd, total_buffer, sizeof(total_buffer));
		}
        // 打开视频
		else if (head->bodyType == VIDEO_OPEN) {
			char body_buffer[sizeof(PACK_VIDEO_BACK)] = { 0 };
			memcpy(body_buffer, rec_buffer + sizeof(PACK_HEAD), sizeof(PACK_VIDEO_BACK));

			char total_buffer[sizeof(PACK_HEAD) + sizeof(PACK_VIDEO_BACK)] = { 0 };
			memcpy(total_buffer, head, sizeof(PACK_HEAD));
			memcpy(total_buffer + sizeof(PACK_HEAD), body_buffer, sizeof(body_buffer));
			int res = write(fd, total_buffer, sizeof(total_buffer));

		}
		free(msg); msg = NULL;
		free(head); head = NULL;
        m_epoller->ModFd(fd, m_connEvent | EPOLLIN);
    }
}

void EpollServer::_Close_Conn(int fd) {
    assert(fd > 0);
    m_epoller->DelFd(fd);
    close(fd);
}
~~~

### 4、UserDB 和 CarDB 数据库调用接口类

#### 4.1 创建数据库root.db和表tbl_msg、tbl_user、tbl_record

![img](https://s2.loli.net/2022/05/19/Lu5vEnZQPlzaRKx.png)

#### 4.2 使用单例模式编写UserDB类，实现tbl_user数据表的调用接口

~~~c++
#ifndef __USERDB_H
#define __USERDB_H

#include <iostream>
#include <string>
#include <list>
#include "./singaldb.h"

using namespace std;

class UserDB {
public:
    static UserDB* getInstance();
    int insertUser(string name, string pwd);
    int searchUser(string name, string pwd);
    int changeState(int state, string name);

private:
    UserDB() = default;

    static UserDB* userdb;

};

#endif /* __USERDB_H */

~~~

~~~c++
#include "userdb.h"
#include "./define.h"

UserDB* UserDB::userdb;

UserDB* UserDB::getInstance() {
    if (UserDB::userdb == NULL) {
        UserDB::userdb = new UserDB();
    }
    return UserDB::userdb;
}

int UserDB::insertUser(string name, string pwd) {
    // 1. sql语句拼接
    char sql[256];
    sprintf(sql, "insert into tbl_user values(null, '%s', '%s', 1)", name.c_str(), pwd.c_str());

    // 2. 数据准备
    char** qres;
    int row, col;

    // 3. 打开数据库并执行sql语句
    int res = SingalDb::getInstance()->dosql(sql, qres, row, col);
    if (res == 0) { return 0; }
    else { return -1; }
} 

int UserDB::searchUser(string name, string pwd) {
    // 1. sql语句拼接 
    char sql[256];
    sprintf(sql, "select * from tbl_user where user_name='%s' and user_pwd='%s'", name.c_str(), pwd.c_str());

    // 2. 数据准备 
    char** qres;
    int row, col;
    // 3. 打开数据库 
    int res = SingalDb::getInstance()->dosql(sql, qres, row, col);
    if (res == 0) {
        if (row > 0) { return 0; }
        else { return 1;}
    } else { return -1; }
}

int UserDB::changeState(int state, string name) {
    // 1. sql语句拼接
    char sql[256];
    sprintf(sql, "update tbl_user set state=%d where user_name='%s'", state, name.c_str());

    // 2. 数据准备 
    char** qres;
    int row, col;

    // 3. 打开数据库 
    int res = SingalDb::getInstance()->dosql(sql, qres, row, col);
    if (res == 0) { return 0; }
    else { return -1; }
}

~~~

#### 4.3 测试UserDB

##### 编写测试主函数 main.cpp

~~~c++
#include "./userdb.h"
#include "./define.h"

int main() {
    string name = "zhanglai";
    string pwd = "123456";
    int ret;
    // 插入用户名和密码到 tbl_user表中
    ret = UserDB::getInstance()->insertUser(name, pwd);
    if (ret == 0) {
        printf("insert OK\n");
    } else {
        printf("insert Bad\n");
    }
    // 根据用户名和密码查询用户信息
    ret = UserDB::getInstance()->searchUser(name, pwd);
    if (ret == 0) {
        printf("search OK\n");
    } else {
        printf("search Bad\n");
    }
    // 更改用户状态 
    int state = 0;
    ret = UserDB::getInstance()->changeState(state, name);
    if (ret == 0) {
        printf("change OK\n");
    } else {
        printf("change Bad\n");
    }

    return 0;
}
~~~

##### 编写编译工具 Makefile 

~~~makefile
CXX := g++
CFLAGS := -std=c++14 -O1 -g
LIB := -lsqlite3
OBJ_DIR := ./obj
BIN_DIR := ./bin

OBJS = ${OBJ_DIR}/main.o ${OBJ_DIR}/singaldb.o ${OBJ_DIR}/userdb.o

.PHONY: mk_dir bin clean

all: mk_dir bin

mk_dir:
	if [ ! -d ${OBJ_DIR}  ]; then mkdir ${OBJ_DIR};fi
	if [ ! -d ${BIN_DIR}  ]; then mkdir ${BIN_DIR};fi

bin: $(OBJS)
	${CXX} ${CFLAGS} ${OBJS} -o ./bin/mian ${LIB}
	
${OBJ_DIR}/main.o: ./main.cpp
	${CXX} ${CFLAGS} -o $@ -c $< ${LIB}

${OBJ_DIR}/singaldb.o: ./singaldb.cpp 
	${CXX} ${CFLAGS} -o $@ -c $< ${LIB}

${OBJ_DIR}/userdb.o: ./userdb.cpp 
	${CXX} ${CFLAGS} -o $@ -c $< ${LIB}

clean:
	rm -rf ./bin ./obj
~~~

##### 测试图片

![img](https://s2.loli.net/2022/05/19/UjQPlBnCLGdNvZV.png)

#### 4.4 使用单例模式编写CarDB类，实现tbl_msg 和 tbl_record数据表的调用接口

~~~c++
#ifndef __CARDB_H
#define __CARDB_H

#include <string>
#include <iostream>
#include <list>
#include <vector>
#include "./singaldb.h"

using namespace std;

class CarDB {
public:
    list<string> select_intime(string car_num);
    list<string> select_carmsg(string car_num, int page);
    list<string> select_allcarmsg(string car_num, string in_time, string out_time, int page);
    list<string> select_carmsg_time(string in_time, string out_time, int page);
    list<string> select_carmsg_intime(string in_time, int page);
    list<string> select_carmsg_outtime(string out_time, int page);

    static CarDB* getInstance();

    int insertCarMsg(string car_num, string in_time, string local, string path);
    int deletecar();
    int updateCarmsg(string car_num, string out_time, int money);
    int totalCar();
    int selectVideoFrame(string name);
    int updateVideoFrame(string name, int count);
    int insertNewVideo(string name, int totalframe);

private:
    CarDB() = default;
    static CarDB* cardb;
};

#endif /* __CARDB_H */
~~~

~~~c++
#include "./cardb.h"
#include "./define.h"

CarDB* CarDB::cardb;

CarDB* CarDB::getInstance() {
    if (CarDB::cardb == NULL) {
        CarDB::cardb = new CarDB();
    }
    return CarDB::cardb;
}

// 将汽车的入场信息插入到tbl_msg表中
int CarDB::insertCarMsg(string car_num, string in_time, string local, string path) {
    // 1. sql 语句拼接
    char sql[256];
    sprintf(sql, "insert into tbl_msg values(null, '%s', 'null', '%s', 'null', '%s', 'null', 0, 1, '%s', 0)", car_num.c_str(), in_time.c_str(), path.c_str(), local.c_str());

    // 2. 数据准备 
    char** qres;
    int row, col;
    
    // 3. 打开数据库, 执行语句 
    int res = SingalDb::getInstance()->dosql(sql, qres, row, col);
    if (res == 0) { return 0; }
    else { return -1; }
}

// 删除tbl_msg表
int CarDB::deletecar() {
    char sql[256];
    sprintf(sql, "delete from tbl_msg");

    char** qres;
    int row, col;

    int res = SingalDb::getInstance()->dosql(sql, qres, row, col);
    if (res == 0) { return 0; }
    else { return -1; }
}

// 根据车牌号查询汽车入场时间和是否是vip
list<string> CarDB::select_intime(string car_num) {
    char sql[256];
    sprintf(sql, "select goin_time, vip from tbl_msg where car_num='%s' and state=1", car_num.c_str());
    
    char** qres;
    int row, col;
    list<string> list;

    int res = SingalDb::getInstance()->dosql(sql, qres, row, col);
    if (res == 0) {
        if (row == 0) { return list; }
        else {
            // 第一行为字段，故需要从第二行开始
            // 将数据存到链表中
            for (int i = col; i < (row + 1) * col; i++) {
                list.push_back(qres[i]);
            }
            return list;        
        }
    }
}

// 根据车牌号更新汽车的部分信息（出场时用）
int CarDB::updateCarmsg(string car_num, string out_time, int money){
	char sql[256];
	sprintf(sql, "update tbl_msg set state=0,take_money=%d,goout_time='%s' where car_num='%s'",money, out_time.c_str(),car_num.c_str());

	char** qres;
	int row, col;
	list<string> list;

	int res = SingalDb::getInstance()->dosql(sql, qres, row, col);
	if (res == 0) { return 0; }
	else { return  -1; }
}

// 统计停车场内的汽车数量
int CarDB::totalCar() {
	char sql[256];
	sprintf(sql, "select COUNT(*) from tbl_msg where state=1");

	char** qres;
	int row, col;
	list<string> list;
	
	int res = SingalDb::getInstance()->dosql(sql, qres, row, col);
	if (res == 0) {
		if (row == 0) { return 0; }
		else { return atoi(qres[1]); }
	}
}

// 根据车牌号查询汽车信息，并将结果存到链表中
list<string> CarDB::select_carmsg(string car_num, int page) {
	char sql[256];
	sprintf(sql, "select car_num,goin_time,goout_time,take_money from tbl_msg where car_num='%s' ORDER BY carmsg_id ASC limit 4 OFFSET %d", car_num.c_str(),page);

	char** qres;
	int row, col;
	list<string> list;
	
	int res = SingalDb::getInstance()->dosql(sql, qres, row, col);
	if (res == 0) {
		if (row == 0) {
			return list;
		} else {
			for (int i = col; i < (row + 1) * col; i++) {
				list.push_back(qres[i]);
			}
			return list;
		}
	}
}

list<string> CarDB::select_allcarmsg(string car_num, string in_time, string out_time, int page) {
	
	char sql[256];
	sprintf(sql, "select car_num,goin_time,goout_time,take_money from tbl_msg where goin_time between '%s' and '%s' and car_num='%s' ORDER BY carmsg_id ASC limit 4 OFFSET %d", in_time.c_str(),out_time.c_str(),car_num.c_str(),page);

	char** qres;
	int row, col;
	list<string> list;

	int res = SingalDb::getInstance()->dosql(sql, qres, row, col);
	if (res == 0) {
		if (row == 0) {
			return list;
		} else {
			for (int i = col; i < (row + 1) * col; i++) {
				list.push_back(qres[i]);
			}
			return list;
		}
	}
}

// 根据入场时间和出场时间，查询汽车信息
list<string> CarDB::select_carmsg_time(string in_time, string out_time, int page) {
	char sql[256];
	sprintf(sql, "select car_num,goin_time,goout_time,take_money from tbl_msg where goin_time between '%s' and '%s' ORDER BY carmsg_id ASC limit 4 OFFSET %d", in_time.c_str(), out_time.c_str(), page);
	
	char** qres;
	int row, col;
	list<string> list;
	
	int res = SingalDb::getInstance()->dosql(sql, qres, row, col);
	if (res == 0) {
		if (row == 0) {
			return list;
		} else {
			for (int i = col; i < (row + 1) * col; i++) {
				list.push_back(qres[i]);
			}
			return list;
		}
	}
}

// 根据入场时间，查询汽车信息
list<string> CarDB::select_carmsg_intime(string in_time, int page) {
	char sql[256];
	sprintf(sql, "select car_num,goin_time,goout_time,take_money from tbl_msg where goin_time >= '%s' ORDER BY carmsg_id ASC limit 4 OFFSET %d", in_time.c_str(), page);

	char** qres;
	int row, col;
	list<string> list;

	int res = SingalDb::getInstance()->dosql(sql, qres, row, col);
	if (res == 0) {
		if (row == 0) {
			return list;
		} else {
			for (int i = col; i < (row + 1) * col; i++) {
				list.push_back(qres[i]);
			}
			return list;
		}
	}
}

// 根据出场时间， 查询汽车信息
list<string> CarDB::select_carmsg_outtime(string out_time, int page) {
	char sql[256];
	sprintf(sql, "select car_num,goin_time,goout_time,take_money from tbl_msg where goout_time <= '%s' ORDER BY carmsg_id ASC limit 4 OFFSET %d", out_time.c_str(), page);

	char** qres;
	int row, col;
	list<string> list;

	int res = SingalDb::getInstance()->dosql(sql, qres, row, col);
	if (res == 0) {
		if (row == 0) {
			return list;
		} else {
			for (int i = col; i < (row + 1) * col; i++) {
				list.push_back(qres[i]);
			}
			return list;
		}
	}
}

// 更新视频记录帧
int CarDB::updateVideoFrame(string name, int count) {
	char sql[256];
	sprintf(sql, "update tbl_record set record_nowframes=%d where record_name='%s'",count,name.c_str());

	char** qres;
	int row, col;

	int res = SingalDb::getInstance()->dosql(sql, qres, row, col);
	if (res == 0) {
		return 0;
	} else {
		return  -1;
	}
}

// 根据名字查询视频记录
int CarDB::selectVideoFrame(string name) {
	char sql[256];
	sprintf(sql, "select record_nowframes from tbl_record where record_name='%s'",name.c_str());

	char** qres;
	int row, col;

	int res = SingalDb::getInstance()->dosql(sql, qres, row, col);
	if (res == 0) {
		if (row == 0) {
			return 0;
		} else {
			return atoi(qres[1]);
		}
	}
}

// 插入视频记录帧到 tbl_record表中
int CarDB::insertNewVideo(string name, int totalframe) {
	char sql[256];
	sprintf(sql, "insert into tbl_record values(null,'%s',0,%d)",
		name.c_str(), totalframe);
	
	char** qres;
	int row, col;

	int res = SingalDb::getInstance()->dosql(sql, qres, row, col);
	if (res == 0) {
		return 0;
	} else {
		return  -1;
	}
}
~~~

#### 4.5 测试CarDB

##### 编写测试主函数 main.cpp

~~~c++
#include "./cardb.h"
#include "./define.h"

int main() {
    string car_num = "浙A88888";
    string in_time = "2022/3/11 10:03";
    string local = "A区18";
    string path = "/home/lai/picture";

    int ret;
    // 汽车信息插入tbl_msg表中
    ret = CarDB::getInstance()->insertCarMsg(car_num, in_time, local, path);
    if (ret == 0) {
        printf("insert OK\n");
    } else {
        printf("insert Bad\n");
    }
    // 根据车牌号查询汽车信息
    list<string> res;
    int page = 1;
    res = CarDB::getInstance()->select_carmsg(car_num, page);
    for (auto it = res.begin(); it != res.end(); it++) {
        cout << *it << endl;
    }

    return 0;
}
~~~

##### 编写编译工具 Makefile 

~~~makefile
CXX := g++
CFLAGS := -std=c++14 -O1 -g
LIB := -lsqlite3
OBJ_DIR := ./obj
BIN_DIR := ./bin

OBJS = ${OBJ_DIR}/main.o ${OBJ_DIR}/singaldb.o ${OBJ_DIR}/cardb.o

.PHONY: mk_dir bin clean

all: mk_dir bin

mk_dir:
	if [ ! -d ${OBJ_DIR}  ]; then mkdir ${OBJ_DIR};fi
	if [ ! -d ${BIN_DIR}  ]; then mkdir ${BIN_DIR};fi

bin: $(OBJS)
	${CXX} ${CFLAGS} ${OBJS} -o ./bin/mian ${LIB}
	
${OBJ_DIR}/main.o: ./main.cpp
	${CXX} ${CFLAGS} -o $@ -c $< ${LIB}

${OBJ_DIR}/singaldb.o: ./singaldb.cpp 
	${CXX} ${CFLAGS} -o $@ -c $< ${LIB}

${OBJ_DIR}/cardb.o: ./cardb.cpp 
	${CXX} ${CFLAGS} -o $@ -c $< ${LIB}

clean:
	rm -rf ./bin ./obj 
~~~

##### 测试图片

![img](https://s2.loli.net/2022/05/19/bflewInvj1FxYSh.png)

### 5、停车管理系统DBServer

#### 5.1 dbserver.h 头文件

~~~c++
#ifndef _DBSERVER_H
#define _DBSERVER_H

#include "./define.h"
#include "./pakeage.h"
#include "./shmfifo.h"
#include "./userdb.h"
#include "./cardb.h"

class DBServer {
public:
    DBServer();
    ~DBServer() = default;

    void Start();

private:
    int m_msgid;
    int m_msgid_back;
    
    bool m_isClose;
};

#endif /* _DBSERVER_H */

~~~

#### 5.2 dbserver.cpp 源文件

~~~c++
#include "./dbserver.h"

ShmFifo shm_fifo1(11, 10, 1024);
ShmFifo shm_fifo2(22, 10, 1024);

DBServer::DBServer() : m_isClose(false) {
    m_msgid = msgget(1234, IPC_CREAT | IPC_EXCL | 0666);
    if (m_msgid == -1) {
        m_msgid = msgget(1234, 0);
    }

    m_msgid_back = msgget(12345, IPC_CREAT | IPC_EXCL | 0666);
    if (m_msgid_back == -1) {
        m_msgid_back = msgget(12345, 0);
    }
}

void DBServer::Start() {
    if (!m_isClose) {
        printf("========== DBServer Start ==========\n");
    }
    
	while (!m_isClose) {
        size_t msgsize = sizeof(MYBUF) - sizeof(long);
        MYBUF* msg = (MYBUF*)malloc(sizeof(MYBUF));

        int ret = msgrcv(m_msgid, msg, msgsize, 1, 0);
        if (ret == -1) {
            perror("msgrcv");
        }

        char buffer[1024] = {0};
        memcpy(buffer, shm_fifo1.shm_read(), sizeof(buffer)); 
        PACK_HEAD* head = (PACK_HEAD*)malloc(sizeof(buffer));
        memcpy(head, buffer, sizeof(PACK_HEAD));

        // 注册
        if (head->bodyType == REGIST_TYPE) {
            PACK_REGIST_LOGIN* regist_login = (PACK_REGIST_LOGIN*)malloc(sizeof(PACK_REGIST_LOGIN));
            memcpy(regist_login, buffer + sizeof(PACK_HEAD), sizeof(PACK_REGIST_LOGIN));

            int res = UserDB::getInstance()->insertUser(regist_login->name, regist_login->pwd);

            PACK_RL_BACK result;
            if (res == 0) {
                result.result = 0;
            } else if (res == -1) {
                result.result = 1;
            }

            MYBUF msg_back;
            msg_back.mtype = 2;

            char send_buffer[sizeof(PACK_HEAD) + sizeof(PACK_RL_BACK)] = {0};
            
            memcpy(send_buffer, head, sizeof(PACK_HEAD));
            memcpy(send_buffer + sizeof(PACK_HEAD), &result, sizeof(PACK_RL_BACK));

            shm_fifo2.shm_write(send_buffer);
            int n = msgsnd(m_msgid_back, &msg_back, msgsize, 0);
        }
        // 登录
        else if (head->bodyType == LOGIN_TYPE) {
       		PACK_REGIST_LOGIN* regist_login = (PACK_REGIST_LOGIN*)malloc(sizeof(PACK_REGIST_LOGIN));
			memcpy(regist_login, buffer + sizeof(PACK_HEAD), sizeof(PACK_REGIST_LOGIN));

			int res = UserDB::getInstance()->searchUser(regist_login->name, regist_login->pwd);
			
			PACK_RL_BACK result;
			if (res == 0) {
				result.result = CarDB::getInstance()->totalCar(); 
			} else {
				result.result = -1; 
			}

			MYBUF msg_back;
			msg_back.mtype = 2;
			char send_buffer[sizeof(PACK_HEAD) + sizeof(PACK_RL_BACK)] = { 0 };
			memcpy(send_buffer, head, sizeof(PACK_HEAD));
			memcpy(send_buffer + sizeof(PACK_HEAD), &result, sizeof(PACK_RL_BACK));

			shm_fifo2.shm_write(send_buffer);
			int n = msgsnd(m_msgid_back, &msg_back, msgsize, 0);   
        }
		// 车辆入场
		else if (head->bodyType == CAR_GETIN) {
			PACK_ENTER* car_enter = (PACK_ENTER*)malloc(sizeof(PACK_ENTER));
			memcpy(car_enter, buffer + sizeof(PACK_HEAD), sizeof(PACK_ENTER));

			int res = CarDB::getInstance()->insertCarMsg(car_enter->car_num, car_enter->now_time, car_enter->location,car_enter->photo_path);
			
			PACK_RL_BACK result;
			memset(&result, 0x0, sizeof(PACK_RL_BACK));
			if (res == 0) {
				result.result = 0;
			} else {
				result.result = 1;
			}

			MYBUF msg_back;
			msg_back.mtype = 2;

			char send_buffer[sizeof(PACK_HEAD) + sizeof(PACK_RL_BACK)] = { 0 };
			memcpy(send_buffer, head, sizeof(PACK_HEAD));
			memcpy(send_buffer + sizeof(PACK_HEAD), &result, sizeof(PACK_RL_BACK));

			shm_fifo2.shm_write(send_buffer);
			int n = msgsnd(m_msgid_back, &msg_back, msgsize, 0);	
		}
		// 车辆出场
		else if (head->bodyType == CAR_GETOUT) {
			PACK_EXIT* car_exit = (PACK_EXIT*)malloc(sizeof(PACK_EXIT));
			memcpy(car_exit, buffer + sizeof(PACK_HEAD), sizeof(PACK_EXIT));
			
			MYBUF msg_back;
			msg_back.mtype = 2;

			list<string> listtemp;
			listtemp = CarDB::getInstance()->select_intime(car_exit->car_num);
			PACK_EXIT_BACK car_exit_back;
			memset(&car_exit_back, 0x0, sizeof(PACK_EXIT_BACK));
			if (listtemp.size() == 0){
				car_exit_back.vip = -1;
			} else {
				string in_time = listtemp.front();
				int vip = stoi(listtemp.back());
				int in_year, in_month, in_day, in_hour, in_min, in_sec;
				int out_year, out_month, out_day, out_hour, out_min, out_sec;
				sscanf(in_time.c_str(), "%d-%2d-%2d %2d:%2d:%2d", &in_year, &in_month, &in_day, &in_hour, &in_min, &in_sec);

				sscanf(car_exit->out_time, "%d-%2d-%2d %2d:%2d:%2d", &out_year, &out_month, &out_day, &out_hour, &out_min, &out_sec);

				int year, month, day, hour, min, sec;
                year = out_year - in_year;
				month = out_month - in_month;
				day = out_day - in_day;
				hour = out_hour - in_hour;

				if (hour <= 0) {
					hour *= (-1);
				}	
				min = out_min - in_min;
				if (min < 0) {
					min *= (-1);
				}
				sec = out_sec - in_sec;
				if (sec < 0) {
					sec *= (-1);
				}	

				char stay_time[64] = { 0 };
				sprintf(stay_time,"%d-%d-%d %d:%d:%d",year,month,day,hour,min,sec);

				if (vip == 1) {
					car_exit_back.money = 0;
				}
				else {
					if (hour == 0) {
						car_exit_back.money = 10;
					} else {
						car_exit_back.money = hour * 10;
					}
				}
				strcpy(car_exit_back.total_time, stay_time);
				strcpy(car_exit_back.in_time, listtemp.front().c_str());

				int updatemsg = CarDB::getInstance()->updateCarmsg(car_exit->car_num, car_exit->out_time,car_exit_back.money);
			}

			char send_buffer[sizeof(PACK_HEAD) + sizeof(PACK_EXIT_BACK)] = { 0 };
			memcpy(send_buffer, head, sizeof(PACK_HEAD));
			memcpy(send_buffer + sizeof(PACK_HEAD), &car_exit_back, sizeof(PACK_EXIT_BACK));

			shm_fifo2.shm_write(send_buffer);
			int n = msgsnd(m_msgid_back, &msg_back, msgsize, 0);	
		}
        // 车辆信息
        else if (head->bodyType == CAR_MSG_TYPE) {
            PACK_CARMSG* car_msg = (PACK_CARMSG*)malloc(sizeof(PACK_CARMSG));
			memcpy(car_msg, buffer + sizeof(PACK_HEAD), sizeof(PACK_CARMSG));

			list<string> car_msglist;
			car_msglist.clear();
			if (car_msg->car_num != "" && car_msg->in_time!= "" &&car_msg->out_time!="")
			{
				car_msglist = CarDB::getInstance()->select_allcarmsg(car_msg->car_num, car_msg->in_time, car_msg->out_time, car_msg->page);
			}
			else if(car_msg->car_num == "" && car_msg->in_time != "" && car_msg->out_time != "")
			{
				car_msglist = CarDB::getInstance()->select_carmsg_time(car_msg->in_time, car_msg->out_time, car_msg->page);
			}
			else if (car_msg->car_num != "" && car_msg->in_time == "" && car_msg->out_time == "")
			{
				car_msglist = CarDB::getInstance()->select_carmsg(car_msg->car_num, car_msg->page);
			}
			else if (car_msg->car_num == "" && car_msg->in_time != "" && car_msg->out_time == "")
			{
				car_msglist = CarDB::getInstance()->select_carmsg_intime(car_msg->in_time, car_msg->page);
			}
			else if (car_msg->car_num == "" && car_msg->in_time == "" && car_msg->out_time != "")
			{
				car_msglist = CarDB::getInstance()->select_carmsg_outtime(car_msg->out_time, car_msg->page);
			}
			else if (car_msg->car_num == "" && car_msg->in_time == "" && car_msg->out_time == ""){}

			int i = 0;
			PACK_ALLCARMSG_BACK carmsg_allback;
			memset(&carmsg_allback, 0x0, sizeof(PACK_ALLCARMSG_BACK));

			list<string>::iterator car_it;
			for (car_it = car_msglist.begin(); car_it != car_msglist.end(); ) {
				strcpy(carmsg_allback.arr[i].car_num, (*car_it++).c_str());
				strcpy(carmsg_allback.arr[i].in_time, (*car_it++).c_str());
				strcpy(carmsg_allback.arr[i].out_time, (*car_it++).c_str());
				carmsg_allback.arr[i].money = stoi(*car_it++);
				i++;
			}
			carmsg_allback.realCount = car_msglist.size() / 4;

			MYBUF msg_back;
			msg_back.mtype = 2;

			char send_buffer[sizeof(PACK_HEAD) + sizeof(PACK_ALLCARMSG_BACK)] = { 0 };
			memcpy(send_buffer, head, sizeof(PACK_HEAD));
			memcpy(send_buffer + sizeof(PACK_HEAD), &carmsg_allback, sizeof(PACK_ALLCARMSG_BACK));

			shm_fifo2.shm_write(send_buffer);
			int n = msgsnd(m_msgid_back, &msg_back, msgsize, 0);
		}
        // 视频信息
		else if (head->bodyType == VIDEO_TYPE) {
			PACK_VIDEO* video = (PACK_VIDEO*)malloc(sizeof(PACK_VIDEO));
			memcpy(video, buffer + sizeof(PACK_HEAD), sizeof(PACK_VIDEO));

			int res = CarDB::getInstance()->insertNewVideo(video->video_name, video->totalFrameCount);
			if (res == 0) {
				//cout << "success" << endl;
			}
		}
        // 打开视频
		else if (head->bodyType == VIDEO_OPEN) {
			PACK_VIDEO* video = (PACK_VIDEO*)malloc(sizeof(PACK_VIDEO));
			memcpy(video, buffer + sizeof(PACK_HEAD), sizeof(PACK_VIDEO));

			int frame = CarDB::getInstance()->selectVideoFrame(video->video_name);
			PACK_VIDEO_BACK video_back;
			video_back.frameCount = frame;

			MYBUF msg_back;
			msg_back.mtype = 2;

			char send_buffer[sizeof(PACK_HEAD) + sizeof(PACK_VIDEO_BACK)] = { 0 };
			memcpy(send_buffer, head, sizeof(PACK_HEAD));
			memcpy(send_buffer + sizeof(PACK_HEAD), &video_back, sizeof(PACK_VIDEO_BACK));

			shm_fifo2.shm_write(send_buffer);
			int res = msgsnd(m_msgid_back, &msg_back, msgsize, 0);
        }
        // 关闭视频
		else if (head->bodyType == VIDEO_CLOSE) {
			PACK_VIDEO* video_close = (PACK_VIDEO*)malloc(sizeof(PACK_VIDEO));
			memcpy(video_close, buffer + sizeof(PACK_HEAD), sizeof(PACK_VIDEO));
			int res = CarDB::getInstance()->updateVideoFrame(video_close->video_name, video_close->totalFrameCount);
			if (res == 0) {
				//cout << "success" << endl;
			}
        }
    }
}
~~~

